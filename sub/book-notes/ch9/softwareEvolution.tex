\documentclass{article}

\usepackage{fancyhdr}
\setlength{\headheight}{12pt}
\setlength{\textwidth}{17.2cm} \setlength{\textheight}{23cm}
\setlength{\topmargin}{-2.5cm} \setlength{\headsep}{1.6cm}
\setlength{\evensidemargin}{-.8cm}
\setlength{\oddsidemargin}{-.8cm}
%\pagestyle{fancy}

%set-up page dimentions
\usepackage[top=1.5 in, bottom = 1.5 in ,left = 1.5 in, right = 1.5in]{geometry}

\setlength{\parskip}{12pt}  % 12 pt = space between paragraphs
\setlength{\parindent}{0pt} % 0 pt  = indentation
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{ifthen}
\usepackage{latexsym}
\usepackage{graphicx}
\usepackage{graphics}
\usepackage{psfrag}
\usepackage{graphpap}
\renewcommand{\P}{\text{P}}
\newcommand{\C}{\text{C}}


\newcommand{\natnums}{{\mathbb N}}
\newcommand{\algnums}{{\mathbb A}}
\newcommand{\rationals}{{\mathbb Q}}
\newcommand{\reals}{{\mathbb R}}
\newcommand{\norm}[1]{\left|\left|#1\right|\right|}
\newcommand{\unorm}[1]{{\left|\left|#1\right|\right|_u}}
\newcommand{\scriptR}{\mathcal{R}}
\newcommand{\scriptP}{\mathcal{P}}
\newcommand{\taggedP}{\dot{\mathcal{P}}}
\newcommand{\scriptQ}{\mathcal{Q}}
\newcommand{\taggedQ}{\dot{\mathcal{Q}}}


% Allows hyperlinks if compiled with pdflatex
\usepackage{hyperref}
\hypersetup{colorlinks}
\usepackage{color}
\definecolor{darkred}{rgb}{0.5,0,0}
\definecolor{darkgreen}{rgb}{0,0.5,0}
\definecolor{darkblue}{rgb}{0,0,0.5}
\hypersetup{ colorlinks,
                linkcolor=darkblue,
                filecolor=darkgreen,
                urlcolor=darkblue,
                citecolor=darkblue }
%hyperlink example is: \href{http://www.google.com}{google}

%add code!
\usepackage{listings}
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
\lstset{ %
backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
basicstyle=\footnotesize,        % the size of the fonts that are used for the code
breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
breaklines=true,                 % sets automatic line breaking
captionpos=b,                    % sets the caption-position to bottom
commentstyle=\color{mygreen},    % comment style
deletekeywords={...},            % if you want to delete keywords from the given language
escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
frame=single,                    % adds a frame around the code
keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
keywordstyle=\color{blue},       % keyword style
language=Octave,                 % the language of the code
morekeywords={*,...},            % if you want to add more keywords to the set
numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
numbersep=5pt,                   % how far the line-numbers are from the code
numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
showstringspaces=false,          % underline spaces within strings only
showtabs=false,                  % show tabs within strings adding particular underscores
stepnumber=2,                    % the step between two line-numbers. If it's 1, each line will be numbered
stringstyle=\color{mymauve},     % string literal style
tabsize=2,                       % sets default tabsize to 2 spaces
title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
}


\begin{document}
 
\setcounter{section}{8}

\section{Software Evolution}
Software evolution can be triggered by changing business requirements, rfeports of software defects, or changed to other systems in a software systen's environment.

"Brownfield software development" is the term to describe situations in which software systems have to be developed and managed in an environment where they are dependent on many other software systems.

The spiral model of software evolution implies a single organization is responsible for both initial development and maintenance.
For cutom software, often the business' own development team maintains the system after the intial release.
When the hand off of maintenence is not seamless, the process of changing the software is called "software maintenance."

\subsection{Evolution processes}
System change proposals are the driver of system evolution.  Come from existing requirements not yet implemented, requests for new requirements, bug reports, and new ideas.

Urgent need for change can come from 3 areas
\begin{enumerate}
    \item Serious system fault occurs and must be repaired to allow normal operation.
    \item Changes to system operating environment have unexpected effects that disrupt normal operations.
    \item Unanticipated changes to the business running the system.
\end{enumerate}

\subsection{Program evolution dynamics}
\textbf{Lehman's Laws}
\begin{enumerate}
    \item System maintenance is an inevitable process.
    \item As a system is changed, the structure is degraded.  Only way to avoid this is preventive maintenance.
    \item Large systems have a dynamic of their own that is established at an early stage in the development process.
    \item Large projects work in a 'saturated' state.  Changes to business resources or staffing has imperceptible effects on long-term evolution.
    \item Adding new functionality to a system inevitably introduces new system faults.
    \item Funtionality must conitnually increase to maintain user satisfaction.
    \item Quality will decline unless modified to reflect changes in operating environment.
    \item Evolution processes incorporate multiagent, multiloop feedback system and they must be treated as feedback systems to achieve significant product improvement.
\end{enumerate}

\subsection{Software maintenance}
Software maintenance is the general process of changing a system after it has been delivered.

Three types of software maintenance:
\begin{enumerate}
    \item Fault repairs.  Coding error - relatively cheap.  Design errors, more expensive and may involve rewriting several program components. Requirements error - most expensive, may need system redesign.
    \item Environmental adaption.  Required when some aspect of the system's environment change.
    \item Functionality addition.  Necessary when the system requirements change in response to organizational or business change.
\end{enumerate}

Also known as corrective, adaptive and perfective maintenance.

Reason's adding functionality is usually more expensive after delivery:
\begin{enumerate}
    \item Team stability.  The original development team may not be the ones doing the maitenance.
    \item Poor development practice.  If developers are not maintainers, little incentive to write maintainable software.
    \item Staff skills.  Maintenance sometimes attracts less-skilled workers.
    \item Program age and structure.
\end{enumerate}
The first three stem from the fact that organizations still consider development and maintenance to be separate activities.


\subsubsection{Maintenance prediction}
Managers want the maintenance to be predicted.
Evaluating the relationship between a system and its environment depends on:
\begin{enumerate}
    \item Number and complexity of system interfaces.
    \item Number of inherently volatile system requirements.
    \item The business process in which the system is used.
\end{enumerate}

Process metrics that can be used for assessing maintainability are:
\begin{enumerate}
    \item Number of requests for corrective maintenance.
    \item Average time for impact ananlysis.
    \item Average time taken to implement a change request.
    \item Number of outstanding change requests.
\end{enumerate}
\subsubsection{Software Reengineering}
Reengineering may involve redocumenting the system, refactoring the system architecture, translating programs to a modern programming language, modifying and updating the structure and values of the system's data.
Two important benefits to reengineering rather than replacement:
\begin{itemize}
    \item Reduced risk.  High risk in redeveloping business-critical software.
    \item Reduced cost.  Cost of reengineering may be significantly less than the cost of developing new software.
\end{itemize}
General model of reegineering process:
\begin{enumerate}
    \item Source code translation.
    \item Reverse engineering.
    \item Program structure improvement.
    \item Program modularization.
    \item Data reengineering.
\end{enumerate}

\subsubsection{Preventative maintenance by refactoring}
Refactoring is process of making improvements to a program to slow down degradation through change.

Reengineering and refactoring are not the same thing.  Reengineering takes place after a system has been maintained for some time.  Refactoring is a continuous process of improvement throughout the development and evolution process.

Signs that code may need to be refactored are:
\begin{enumerate}
    \item Duplicate code.
    \item Long methods.
    \item Switch (case) statements.
    \item Data clumping.
    \item Speculative generality.
\end{enumerate}

\subsection{Legacy System Management}
Four strategic options:
\begin{enumerate}
    \item Scrap the system completely.
    \item Leave the system unchanged and continued with regular maintenance.
    \item Reengineer the system to improve its maintainability.
    \item Replace all or parts of the system with a new system.
\end{enumerate}

Four basic issues that you have to discuss
\begin{enumerate}
    \item The use of the system.
    \item The business processes that are supported.
    \item The system dependability.
    \item System outputs.
\end{enumerate}
 Factors used in environment assessment:
\begin{enumerate}
    \item Supplier stability.
    \item Failure rate.
    \item Age.
    \item Performance.
    \item Support requirements.
    \item Maintenance costs.
    \item Interoperability.
\end{enumerate}

Factors used in application assessment.
\begin{enumerate}
    \item Understandability.
    \item Documentation.
    \item Data.
    \item Performance.
    \item Programming language.
    \item Configuration management.
    \item Test data.
    \item Personnel skills.
\end{enumerate}

Data that may be useful in quality assessment are:
\begin{enumerate}
    \item Number of system change requests.
    \item Number of user interfaces.
    \item Volume of data used by the system.
\end{enumerate}



\end{document}
